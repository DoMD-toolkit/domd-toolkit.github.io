<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DoMD-Toolkit Terminal</title>
    <link href="https://fonts.loli.net/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --phosphor-main: #33ff00;
            --phosphor-dim: #1a8000;
            --bg-color: #050505;
            --font-size: 1.5rem;
        }
        * { box-sizing: border-box; }
        body {
            background-color: #000;
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'VT323', monospace;
            overflow: hidden;
            color: var(--phosphor-main);
        }

        /* 终端外壳 */
        .crt-frame {
            width: 95vw;
            height: 90vh;
            background: var(--bg-color);
            border: 3px solid #333;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 60px rgba(0,0,0,0.7), 0 0 15px rgba(51, 255, 0, 0.1);
        }

        /* 屏幕区域 */
        .screen {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 30px;
            overflow-y: auto;
            font-size: var(--font-size);
            text-shadow: 0 0 4px var(--phosphor-dim);
            scrollbar-width: none;
        }
        .screen::-webkit-scrollbar { display: none; }

        /* CRT 扫描线 */
        .crt-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%),
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            z-index: 99;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.97; } 50% { opacity: 1; } 100% { opacity: 0.98; }
        }

        /* ASCII Art */
        .ascii-art {
            font-family: 'VT323', monospace;
            white-space: pre;
            font-size: 14px;
            line-height: 14px;
            margin-bottom: 20px;
            color: var(--phosphor-main);
        }

        /* 输入行 */
        .input-line { display: block; word-wrap: break-word; }
        .prompt { margin-right: 8px; white-space: nowrap; float: left; }
        #typed-content { white-space: pre-wrap; word-break: break-all; }
        .cursor { display: inline; color: var(--phosphor-main); animation: blink 1s step-end infinite; vertical-align: baseline; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        #hidden-input { position: fixed; bottom: 0; left: 0; opacity: 0; width: 1px; height: 1px; pointer-events: none; }

        /* 文件样式 */
        .dir-name { color: #5dade2; font-weight: bold; }
        .file-name { color: var(--phosphor-main); }
        .error-msg { color: #e74c3c; }
        .output-line { margin-bottom: 5px; clear: both; }

        /* 图片特效 (保留) */
		.crt-image {
			display: block;
			max-width: 100%;
			width: 400px;
			margin: 15px 0;
			border: 2px solid var(--phosphor-main);
			
			filter: contrast(1.2) brightness(1.1);
			image-rendering: pixelated;
			
			/* 初始状态：下方 100% 被裁剪（看不见） */
			clip-path: inset(0 0 100% 0);
			opacity: 1;

			/* 关键修改：
			   原代码: steps(15, end) -> 分15次跳跃，导致卡顿
			   新代码: linear         -> 线性匀速，丝滑扫描
			*/
			animation: scan-load 4s linear forwards;
		}

		/* scan-load 关键帧保持不变 */
		@keyframes scan-load {
			0% { clip-path: inset(0 0 100% 0); }
			100% { clip-path: inset(0 0 0 0); }
		}

        /* --- 新增：代码块样式 --- */
        .code-block {
            border: 1px solid var(--phosphor-dim);
            margin: 10px 0;
            position: relative;
            background: rgba(0, 20, 0, 0.3);
            padding-top: 20px;
        }
        .code-header {
            position: absolute; top: 0; left: 0;
            background: var(--phosphor-dim);
            color: #000;
            padding: 0 8px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .code-content {
            display: block;
            padding: 10px;
            font-family: 'VT323', monospace;
            white-space: pre;
            overflow-x: auto;
            color: #aaddff;
        }
        /* 代码高亮配色 */
        .hl-keyword { color: #ff79c6; font-weight: bold; }
        .hl-string  { color: #f1fa8c; }
        .hl-comment { color: #6272a4; font-style: italic; }
        .hl-func    { color: #8be9fd; }

        @media (max-width: 600px) {
            :root { --font-size: 1.1rem; }
            .ascii-art { font-size: 8px; line-height: 8px; }
            .screen { padding: 15px; }
        }
    </style>
</head>
<body>
<div class="crt-frame">
    <div class="crt-overlay"></div>
    <div class="screen" id="screen">
        <div id="ascii-container"></div>
        <div id="output"></div>
        
        <div class="input-line">
            <span class="prompt">
                <span id="p-user">guest@domd</span>:<span id="p-path">/</span>$
            </span>
            <span id="typed-content"></span><span class="cursor">_</span>
        </div>
        <input type="text" id="hidden-input" autocomplete="off" spellcheck="false">
    </div>
</div>

<script>
    /* --- 1. 数据结构 --- */
    const fs = {
        '/': {
            type: 'dir',
            children: {
                'about.txt': { type: 'file', content: ["SYSTEM: DoMD-Toolkit v1.0", "KERNEL: Python >= 3.12", "STATUS: Online"] },
                'members': { 
                    type: 'dir', 
                    children: {
                        'myron-li.txt': { 
                            type: 'file', 
                            content: ["NAME: Ming-yang Li", "ROLE: Researcher", '<img src="/images/mingyang-li.jpg" class="crt-image">']
                        },
                        'ruishi.txt': { 
                            type: 'file', 
                            content: ["NAME: Rui Shi", "ROLE: Archmage", '<img src="https://www.domd.today/images/ruishi.jpg" class="crt-image">', 'Publications:'], 
                            // 确保这个远程文件里包含 <code class='python'>...</code> 来测试高亮
                            url:'/contents/ruishi.txt'
                        },
                        'code_test.txt': {
                            type: 'file',
                            content: [
                                "Here is a code demo:",
                                "<code class='python'>",
                                "import os",
                                "def hello():",
                                "    print('Hello World')",
                                "</code>"
                            ]
                        }
                    }
                },
                'projects': { 
                    type: 'dir', 
                    children: {
                        'chem_ai': { type: 'dir', children: {} },
                        'notes.txt': { type: 'file', content: ["Project pending..."] }
                    }
                }
            }
        }
    };

    /* --- 2. 全局状态 --- */
    let currentPath = [];
    const hiddenInput = document.getElementById('hidden-input');
    const typedContent = document.getElementById('typed-content');
    const outputDiv = document.getElementById('output');
    const pathSpan = document.getElementById('p-path');
    const screenDiv = document.getElementById('screen');
    const asciiContainer = document.getElementById('ascii-container');

    /* --- 3. 核心工具函数 --- */

    function scrollToBottom() {
        screenDiv.scrollTop = screenDiv.scrollHeight;
    }

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // 图片预加载 (你的逻辑完全保留)
    function preloadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error("Image load failed"));
            img.src = src;
        });
    }

    // --- 新增：代码高亮与解析 ---

    // 高亮器
    function applyHighlight(code, lang) {
        let html = code.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        html = html.replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="hl-string">$&</span>');
        html = html.replace(/(\/\/.*|#.*)/g, '<span class="hl-comment">$&</span>');
        html = html.replace(/\b(def|class|import|from|return|if|else|elif|for|while|try|except|const|let|var|function|async|await|print|console|log)\b/g, '<span class="hl-keyword">$&</span>');
        html = html.replace(/(\w+)(?=\()/g, '<span class="hl-func">$1</span>');
        return html;
    }

    // 解析器：把文本拆成 [文本, 代码, 文本...]
    function parseRawText(text) {
        const segments = [];
        const regex = /<code\s+class=['"](.*?)['"]>([\s\S]*?)<\/code>/gi;
        let lastIndex = 0;
        let match;

        while ((match = regex.exec(text)) !== null) {
            if (match.index > lastIndex) {
                segments.push({ type: 'text', val: text.substring(lastIndex, match.index) });
            }
            segments.push({ type: 'code', lang: match[1], val: match[2].trim() });
            lastIndex = regex.lastIndex;
        }
        if (lastIndex < text.length) {
            segments.push({ type: 'text', val: text.substring(lastIndex) });
        }
        return segments;
    }

    // --- 核心渲染引擎 (融合了你的图片逻辑 + 代码逻辑) ---
    async function renderRichText(rawString) {
        const segments = parseRawText(rawString);

        for (let seg of segments) {
            if (seg.type === 'text') {
                // 普通文本处理 (包含你的图片逻辑)
                const lines = seg.val.split('\n');
                
                for (let line of lines) {
                    // 过滤掉纯空行，避免过多空隙，但保留有意义的换行
                    // if (line.trim() === '') continue; 

                    const div = document.createElement('div');
                    div.className = 'output-line';

                    // --- 这里的逻辑完全复用你之前的 printText 里的图片处理 ---
                    if (line.includes('<img')) {
                        const srcMatch = line.match(/src="([^"]+)"/);
                        const imgSrc = srcMatch ? srcMatch[1] : null;
                        if (imgSrc) {
                            const loadingDiv = document.createElement('div');
                            loadingDiv.className = 'output-line';
                            loadingDiv.style.color = 'var(--phosphor-dim)';
                            loadingDiv.innerText = `[SYSTEM] Buffer receiving data...`;
                            outputDiv.appendChild(loadingDiv);
                            scrollToBottom();

                            try {
                                await preloadImage(imgSrc); // 等待下载
                                outputDiv.removeChild(loadingDiv);
                                div.innerHTML = line; 
                                outputDiv.appendChild(div);
                                scrollToBottom();
                                await sleep(4050); // 等待扫描动画
                            } catch (e) {
                                outputDiv.removeChild(loadingDiv);
                                div.innerHTML = `<span class="error-msg">[ERROR] Image corrupted</span>`;
                                outputDiv.appendChild(div);
                            }
                        }
                    } else {
                        // 普通打字机效果
                        outputDiv.appendChild(div);
                        // 如果是 HTML 标签开头（如 ls 输出的 span），直接显示，不打字
                        if (line.trim().startsWith('<') && !line.includes('<img')) {
                            div.innerHTML = line;
                        } else {
                            for (let char of line) {
                                div.textContent += char;
                                scrollToBottom();
                                await sleep(5);
                            }
                        }
                    }
                    scrollToBottom();
                    await sleep(10);
                }
            } 
            else if (seg.type === 'code') {
                // --- 代码块处理 (新功能) ---
                const codeBox = document.createElement('div');
                codeBox.className = 'code-block';
                
                const header = document.createElement('div');
                header.className = 'code-header';
                header.innerText = seg.lang.toUpperCase();
                
                const contentPre = document.createElement('div');
                contentPre.className = 'code-content';
                
                codeBox.appendChild(header);
                codeBox.appendChild(contentPre);
                outputDiv.appendChild(codeBox);
                scrollToBottom();

                // 逐字打印代码
                const lines = seg.val.split('\n');
                for (let line of lines) {
                    for (let char of line) {
                        contentPre.textContent += char;
                        await sleep(2);
                    }
                    contentPre.textContent += '\n';
                    scrollToBottom();
                }
                // 应用高亮
                contentPre.innerHTML = applyHighlight(seg.val, seg.lang);
            }
        }
    }

    /* --- 4. 路径解析 --- */
    function resolvePath(pathStr) {
        if (!pathStr) return null;
        if (pathStr === '.') return getCurrentDirObj();
        let node = (pathStr.startsWith('/')) ? fs['/'] : getCurrentDirObj();
        const parts = pathStr.split('/').filter(p => p && p !== '.');
        for (let p of parts) {
            if (p === '..') return null; // 简单处理
            if (node.children && node.children[p]) node = node.children[p];
            else return null;
        }
        return node;
    }
    function getCurrentDirObj() {
        let dir = fs['/'];
        for (let p of currentPath) dir = dir.children[p];
        return dir;
    }

    /* --- 5. 命令执行 --- */
    async function execute(input) {
        const cleanInput = input.trim();
        if (!cleanInput) { scrollToBottom(); return; }
        
        const parts = cleanInput.split(/\s+/);
        const cmd = parts[0].toLowerCase();
        let arg = parts[1] || "";
        if (arg.length > 1 && arg.endsWith('/')) arg = arg.slice(0, -1);

        const historyLine = document.createElement('div');
        historyLine.className = 'output-line';
        historyLine.innerHTML = `<span style="opacity:0.7">guest@domd:${pathSpan.innerText}$</span> ${cleanInput}`;
        outputDiv.appendChild(historyLine);

        switch (cmd) {
            case 'help':
                // 使用新引擎渲染帮助
                await renderRichText("DoMD-Toolkit Shell v1.0\n-----------------------\nls [dir/file] : List contents\ncd [dir]      : Change directory (.. for up)\ncat [file]    : Read file\nclear         : Clear screen");
                break;
            case 'clear':
                outputDiv.innerHTML = '';
                break;
            case 'ls':
                let targetObj = (!arg || arg === '.') ? getCurrentDirObj() : resolvePath(arg);
                if (!targetObj) {
                    await renderRichText(`ls: cannot access '${arg}': No such file`);
                } else if (targetObj.type === 'dir') {
                    const keys = Object.keys(targetObj.children || {}).sort();
                    if (keys.length === 0) await renderRichText("(empty)");
                    else {
                        const fmt = keys.map(k => {
                            const item = targetObj.children[k];
                            return (item.type === 'dir') ? `<span class="dir-name">${k}/</span>` : `<span class="file-name">${k}</span>`;
                        }).join('  ');
                        // ls 输出直接给 div，不需要打字机
                        const div = document.createElement('div');
                        div.className = 'output-line';
                        div.innerHTML = fmt;
                        outputDiv.appendChild(div);
                    }
                } else if (targetObj.type === 'file') {
                    await renderRichText(arg);
                }
                break;
            case 'cd':
                if (!arg || arg === '/') currentPath = [];
                else if (arg === '..') { if (currentPath.length > 0) currentPath.pop(); }
                else {
                    const t = resolvePath(arg);
                    if (t && t.type === 'dir') {
                        if (!arg.includes('/')) currentPath.push(arg);
                        else await renderRichText("cd: complex path not supported in demo");
                    } else {
                        await renderRichText(`cd: ${arg}: No such directory`);
                    }
                }
                pathSpan.innerText = currentPath.length ? '/' + currentPath.join('/') : '/';
                break;
            case 'cat':
                if (!arg) { await renderRichText("Usage: cat [filename]"); break; }
                const fileTarget = resolvePath(arg);
                if (!fileTarget || fileTarget.type !== 'file') {
                    await renderRichText(`cat: ${arg}: No such file`);
                } else {
                    hiddenInput.disabled = true;

                    // 1. 本地内容
                    if (fileTarget.content) {
                        // 数组转字符串，交给新引擎处理
                        await renderRichText(fileTarget.content.join('\n'));
                    }

                    // 2. 远程内容
                    if (fileTarget.url) {
                        if (fileTarget.content) await renderRichText("\n--- FETCHING REMOTE DATA ---\n");
                        else await renderRichText(`Connecting to ${fileTarget.url}...`);

                        try {
                            await sleep(500);
                            const res = await fetch(fileTarget.url);
                            if (!res.ok) throw new Error(`HTTP ${res.status}`);
                            const text = await res.text();
                            
                            await renderRichText(`[200 OK] Size: ${text.length} bytes.\n`);
                            // 丢给新引擎，它会自动识别里面的 <code...> 并高亮
                            await renderRichText(text);
                        } catch (e) {
                            await renderRichText(`<span class="error-msg">[ERROR] Connection failed: ${e.message}</span>`);
                        }
                    }
                    hiddenInput.disabled = false;
                    hiddenInput.focus();
                }
                break;
            default:
                await renderRichText(`bash: ${cmd}: command not found`);
        }
        scrollToBottom();
    }

    /* --- 6. 事件监听 --- */
    document.body.addEventListener('click', () => hiddenInput.focus());
    hiddenInput.addEventListener('input', () => { typedContent.innerText = hiddenInput.value; scrollToBottom(); });
    hiddenInput.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter') {
            const val = hiddenInput.value;
            hiddenInput.value = '';
            typedContent.innerText = '';
            await execute(val);
        }
        if (e.key === 'Tab') {
            e.preventDefault();
            // 简单的 Tab 补全逻辑
            const val = hiddenInput.value;
            const parts = val.split(/\s+/);
            const currentInput = parts[parts.length - 1];
            if (!currentInput) return;
            
            let matches = [];
            let prefix = "";
            if (parts.length === 1 && !currentInput.includes('/')) {
                const cmds = ['ls', 'cd', 'cat', 'help', 'clear'];
                matches = cmds.filter(c => c.startsWith(currentInput));
            } else {
                let dirObj = getCurrentDirObj();
                let searchPrefix = currentInput;
                const lastSlash = currentInput.lastIndexOf('/');
                if (lastSlash !== -1) {
                    const pathStr = currentInput.substring(0, lastSlash);
                    searchPrefix = currentInput.substring(lastSlash + 1);
                    prefix = pathStr + "/";
                    const pDir = resolvePath(pathStr);
                    if (pDir && pDir.type === 'dir') dirObj = pDir;
                    else return;
                }
                const candidates = Object.keys(dirObj.children || {});
                matches = candidates.filter(c => c.startsWith(searchPrefix));
            }
            if (matches.length === 1) {
                let m = matches[0];
                let completion = prefix + m;
                // 简单判定是否加 /
                let checkDir = getCurrentDirObj();
                if (prefix) checkDir = resolvePath(prefix.slice(0, -1));
                if (checkDir.children[m] && checkDir.children[m].type === 'dir') completion += '/';
                else if (parts.length === 1) completion += ' ';
                
                parts[parts.length - 1] = completion;
                hiddenInput.value = parts.join(' ');
                typedContent.innerText = hiddenInput.value;
            }
        }
    });

    /* --- 7. 初始化 --- */
    window.onload = () => {
        const asciiLogo = 
` ____        __  __ ____   _____           _ _    _ _   
|  _ \\  ___ |  \\/  |  _ \\ |_   _|__   ___ | | | _(_) |_ 
| | | |/ _ \\| |\\/| | | | |  | |/ _ \\ / _ \\| | |/ / | __|
| |_| | (_) | |  | | |_| |  | | (_) | (_) |   <| | |_  
|____/ \\___/|_|  |_|____/   |_|\\___/ \\___/|_|_|\\_\\_|\\__| v1.0`;

        const pre = document.createElement('pre');
        pre.className = 'ascii-art';
        pre.textContent = asciiLogo;
        asciiContainer.appendChild(pre);

        renderRichText("Welcome to DoMD-Toolkit.\nType 'help' for instructions.");
        hiddenInput.focus();
    };
</script>
</body>
</html>
